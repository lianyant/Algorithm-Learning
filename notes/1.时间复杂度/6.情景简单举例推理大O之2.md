## **一、时间复杂度的数学定义**

时间复杂度采用 **大O符号（Big O Notation）** 的数学形式化定义，描述算法执行时间随输入规模 \( n \) 增长的**渐近上界**。

### **1. 形式化定义**

给定两个函数 \( T(n) \) 和 \( f(n) \)，我们说：
\[
T(n) = O\bigl(f(n)\bigr)
\]
当且仅当**存在**正常数（通常取正实数） \( c > 0 \) 和一个阈值 \( n_0 \)，使得对于所有 \( n \geq n_0 \)，下式成立：
\[
T(n) \leq c \cdot f(n).
\]

其中：
- \( T(n) \): 算法实际执行的基本操作次数或运行时间
- \( f(n) \): 用来描述增长趋势的参考函数
- \( c \): 正实常数系数
- \( n_0 \): 起始规模阈值

在大O符号下，我们只关注规模 \( n \) 充分大时，算法复杂度的**上界**增长趋势。

---

## **二、推导公式的核心步骤**

通过分析代码，先找出算法的基本操作次数 \( T(n) \)，再化简得到大O形式 \( O(f(n)) \)。以下给出常见示例。

### **示例1：简单循环**

```cpp
void func(int n) {
    for (int i = 0; i < n; i++) {    // 循环条件判断：执行n+1次
        printf("%d", i);             // 循环体：执行n次
    }
}
```

1. **统计基本操作次数**  
   - 循环条件判断：\( n + 1 \) 次（最后一次判断失败）  
   - 循环体执行：\( n \) 次  
   - 总次数 \( T(n) = (n + 1) + n = 2n + 1 \)

2. **确定最高阶项**  
   - 忽略低阶项（+1）和常数系数（2），得到 \( T(n) = O(n) \)

3. **数学验证示例**  
   - 令 \( c = 3 \)，\( n_0 = 1 \)  
   - 对所有 \( n \ge 1 \)，有 \( 2n + 1 \le 3n \)  
   - 因此 \( T(n) = O(n) \) 成立

---

### **示例2：嵌套循环**

```cpp
void func(int n) {
    for (int i = 0; i < n; i++) {        // 外层循环n次
        for (int j = 0; j < n; j++) {    // 内层循环n次
            printf("%d,%d", i, j);       // 基本操作：执行n×n次
        }
    }
}
```

1. **统计基本操作次数**  
   - 外层循环：\( n \) 次  
   - 内层循环：每次外层循环执行 \( n \) 次  
   - 故总次数 \( T(n) = n \times n = n^2 \)

2. **直接化简**  
   \[
   T(n) = n^2 \quad \Longrightarrow \quad O(n^2)
   \]

3. **数学验证示例**  
   - 令 \( c = 1 \), \( n_0 = 0 \)  
   - 对所有 \( n \ge 0 \)，有 \( n^2 \le 1 \cdot n^2 \)  
   - 显然满足 \( T(n) = O(n^2) \)

---

## **三、递归算法的递推公式推导**

递归算法常通过 **递推方程（Recurrence Relation）** 来求时间复杂度。

### **示例3：斐波那契数列递归**

```cpp
int fib(int n) {
    if (n <= 1) return n;           // 递归基：O(1)
    return fib(n-1) + fib(n-2);     // 递归调用：两次分支
}
```

1. **建立递推方程**  
   \[
   T(n) = T(n-1) + T(n-2) + O(1).
   \]

2. **近似简化**  
   - 当 \( n \) 较大时，\( T(n-1) \) 与 \( T(n-2) \) 同级，常见的粗略上界做法：  
   \[
   T(n) \approx 2\,T(n-1).
   \]  
   - 由此可得 \( T(n) \) 至少是指数级增长，常用上界 \( O(2^n) \)。

> **注**：更加精确的分析可得 \( T(n) \approx O(\varphi^n)\)，\(\varphi \approx 1.618\) 为黄金比。对于大O级别，\( O(2^n) \) 虽不最紧，但简单易用。

3. **递推展开**  
   \[
   T(n) \approx 2\,T(n-1)
          = 2^2\,T(n-2)
          = 2^3\,T(n-3)
          = \dots = 2^n \, T(0).
   \]

4. **结论**  
   \[
   T(n) = O(2^n).
   \]

---

## **四、分治算法的主定理应用**

对于形如
\[
T(n) = a\,T\bigl(\tfrac{n}{b}\bigr) + f(n)
\]
的递归式，可以使用 **主定理（Master Theorem）** 来快速求解。主定理主要有三种情形（此处以常用版本为例）：

1. 若 \( f(n) = O\bigl(n^{\log_b a - \epsilon}\bigr)\) （小于分治所占的规模），则 
   \[
   T(n) = \Theta\bigl(n^{\log_b a}\bigr).
   \]
2. 若 \( f(n) = \Theta\bigl(n^{\log_b a}\log^k n\bigr)\) （与分治规模相当），则
   \[
   T(n) = \Theta\bigl(n^{\log_b a}\log^{k+1} n\bigr).
   \]
3. 若 \( f(n) = \Omega\bigl(n^{\log_b a + \epsilon}\bigr)\) （大于分治规模），且满足某些正则条件，则
   \[
   T(n) = \Theta\bigl(f(n)\bigr).
   \]

### **示例4：归并排序**

```cpp
void mergeSort(int arr[], int l, int r) {
    if (l >= r) return;
    int m = l + (r - l)/2;       // 分：O(1)
    mergeSort(arr, l, m);        // 治：T(n/2)
    mergeSort(arr, m+1, r);      // 治：T(n/2)
    merge(arr, l, m, r);         // 合：O(n)
}
```

1. **建立递推式**  
   \[
   T(n) = 2\,T\Bigl(\frac{n}{2}\Bigr) + O(n).
   \]

2. **主定理参数**  
   - \( a = 2 \)，\( b = 2 \)，则 \(\log_b a = \log_2 2 = 1\)。  
   - \( f(n) = O(n) = \Theta\bigl(n^1 \log^0 n\bigr) \)。

3. **对照主定理情形2**  
   - 因为 \( f(n) \) 与 \( n^{\log_b a} = n^1 \) 同阶（\(\log^0 n\) 表示无额外对数因子），  
   - 故时间复杂度：
   \[
   T(n) = \Theta\bigl(n \log n\bigr).
   \]

---

## **五、多项式复杂度化简的数学证明**

以 \( T(n) = 3n^2 + 5n + 2 \) 为例，证明其属于 \( O(n^2) \)。

1. **目标不等式**  
   \[
   3n^2 + 5n + 2 \;\le\; c \cdot n^2 \quad \bigl(\forall n \ge n_0\bigr).
   \]

2. **化到同一边**  
   \[
   3n^2 + 5n + 2 \le c\,n^2 \;\;\Longrightarrow\;\; (c - 3)n^2 - 5n - 2 \ge 0.
   \]

3. **选择系数**  
   - 取 \( c = 4 \)，则  
   \[
   (4 - 3)n^2 - 5n - 2 = n^2 - 5n - 2 \ge 0.
   \]

4. **求解二次方程**  
   \[
   n^2 - 5n - 2 = 0 
   \;\;\Longrightarrow\;\; 
   n = \frac{5 \pm \sqrt{25 + 8}}{2} \approx 5.37.
   \]
   - 因为抛物线开口向上，当 \( n > 5.37 \) 时，上式 \( \ge 0 \) 成立。

5. **确定阈值**  
   - 取 \( n_0 = 6 \)。当 \( n \ge 6 \)，可验证
   \[
   3n^2 + 5n + 2 \;\le\; 4\,n^2.
   \]

6. **结论**  
   \[
   T(n) = O(n^2).
   \]

---

## **六、极限定义法验证复杂度**

若想用极限法来严格验证 \( T(n) = O(f(n)) \)，通常看：
\[
\lim_{n \to \infty} \frac{T(n)}{f(n)}.
\]
- 当该极限为**有限常数**（尤其是大于 0 的有限值）时，既说明 \( T(n) \) = \( O(f(n)) \)，也可以推断 \( T(n) = \Omega(f(n)) \)，即 \( T(n) \) 与 \( f(n) \) 同阶 (\(\Theta\))。

### **示例：\( T(n) = 2n^2 + 3n \) 与 \( O(n^2) \)**

\[
\lim_{n \to \infty} \frac{2n^2 + 3n}{n^2}
= \lim_{n \to \infty} \left(2 + \frac{3}{n}\right)
= 2.
\]
因为极限为常数，故 \( T(n) = O(n^2) \) 且更进一步可说 \( T(n) = \Theta(n^2) \)。

---

## **七、时间复杂度常见分类总结**

| **类型**           | **数学表示**       | **关键特征**                               | **典型算法**         |
|--------------------|--------------------|--------------------------------------------|----------------------|
| **常数时间**       | \( O(1) \)         | 无循环或固定次数操作                       | 哈希表查询           |
| **对数时间**       | \( O(\log n) \)    | 问题规模按固定比例缩小                     | 二分查找             |
| **线性时间**       | \( O(n) \)         | 单层循环遍历                               | 线性搜索、数组求和   |
| **线性对数时间**   | \( O(n \log n) \)  | 分治/折半递归，含一次线性合并或划分        | 快速排序、归并排序   |
| **平方时间**       | \( O(n^2) \)       | 双重嵌套循环                               | 冒泡排序、选择排序   |
| **指数时间**       | \( O(2^n) \) 或更精确 \( O(\varphi^n) \) | 递归爆炸式增长                    | 子集枚举、斐波那契递归|
| **阶乘时间**       | \( O(n!) \)        | 尝试所有排列组合                           | 全排列算法           |

---

### **如需更具体的复杂度推导或代码验证，请继续提供相应的算法示例。** 

上述内容涵盖了从大O的定义、常见循环、递归与分治算法的复杂度分析方法，以及几种典型证明与验证技术，适合作为算法复杂度入门的参考。祝学习顺利!