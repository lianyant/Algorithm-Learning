本文详细解释算法时间复杂度的概念、定义和公式推导过程，并用C++代码示例辅助说明。

---

### **一、时间复杂度的核心概念**
#### **1. 定义**
时间复杂度（Time Complexity）是衡量算法运行时间随输入规模增长的变化趋势的指标。它不计算具体时间，而是用**数学函数**描述算法执行的基本操作次数与输入规模n的关系。

#### **2. 关键点**
- **输入规模（n）**：通常指问题的大小（如数组长度、矩阵维度）
- **基本操作**：算法中最耗时的核心操作（如循环、递归、比较）
- **渐进趋势**：关注n→∞时的增长趋势，忽略常数项和低阶项

---

### **二、时间复杂度的数学推导**
#### **1. 基本步骤**
```markdown
1. 确定算法的基本操作
2. 计算基本操作的执行次数T(n)
3. 用大O记号表示T(n)的渐进上界
```

#### **2. 推导示例**
**案例**：线性查找算法
```cpp
int linearSearch(int arr[], int n, int target) {
    for (int i = 0; i < n; i++) {  // 基本操作：比较
        if (arr[i] == target) {
            return i;
        }
    }
    return -1;
}
```

**推导过程**：
1. **基本操作**：`arr[i] == target`比较
2. **执行次数**：
   - 最好情况：1次（目标在第一个位置）
   - 最坏情况：n次（目标在最后或不存在）
   - 平均情况：n/2次
3. **渐进分析**：
   - 忽略常数项和系数，只保留最高阶项
   - 最好情况O(1), 最坏和平均情况都是O(n)

---

### **三、常见时间复杂度类型**
| 类型         | 数学表示   | 典型算法                     | C++示例                          |
|--------------|------------|------------------------------|----------------------------------|
| **常数阶**   | O(1)       | 数组索引访问                  | `int x = arr[0];`                |
| **对数阶**   | O(log n)   | 二分查找                      | `while (low <= high) { mid = low + (high - low) / 2; ... }` |
| **线性阶**   | O(n)       | 遍历数组                      | `for (int i = 0; i < n; i++) { ... }` |
| **线性对数阶**| O(n log n) | 快速排序/归并排序             | `sort(arr, arr + n);`            |
| **平方阶**   | O(n²)      | 冒泡排序或一般的两层循环                      | `for (int i = 0; i < n; i++) { for (int j = 0; j < n; j++) { ... } }` |
| **指数阶**   | O(2ⁿ)      | 斐波那契递归                  | `int fib(int n) { return (n <= 1) ? n : fib(n-1) + fib(n-2); }` |

---

### **四、复杂场景的推导方法**
#### **1. 多重循环**
```cpp
for (int i = 0; i < n; i++) {         // O(n)
    for (int j = 0; j < n; j++) {     // O(n)
        // 基本操作
    }
}
```
- **总复杂度**：O(n) × O(n) = O(n²)

#### **2. 递归算法**
```cpp
int factorial(int n) {
    if (n <= 1) return 1;            // 递归基
    return n * factorial(n - 1);     // 递归调用
}
```
等价于一次对 factorial(n-1) 的调用再加上一个乘法操作
- **递推公式**：T(n) = T(n-1) + O(1)
- **展开求解**：T(n) = T(n-1) + 1 = T(n-2) + 2 = ... = T(0) + n = O(n)

#### **3. 分治算法**
```cpp
void mergeSort(int arr[], int l, int r) {
    if (l < r) {
        int m = l + (r - l) / 2;      // 分
        mergeSort(arr, l, m);         // 治
        mergeSort(arr, m + 1, r);     // 治
        merge(arr, l, m, r);          // 合（O(n)）
    }
}
```
- **递推公式**：T(n) = 2T(n/2) + O(n)
- **主定理求解**：T(n) = O(n log n)

---

### **五、时间复杂度分析的实用技巧**
1. **关注最坏情况**：
   - 算法性能的底线保障
   - 示例：快速排序最坏O(n²)，平均O(n log n)

实际工程中有时也需要关注“平均情况”或“期望时间”，但在做安全/性能兜底时，往往要保证最坏情况下不会“爆炸”。
2. **忽略低阶项**：
   - 当n→∞时，低阶项影响可忽略
   - 示例：T(n) = 3n² + 100n + 1000 → O(n²)

3. **注意隐藏成本**：
   - 容器操作（如`std::vector::push_back`均摊O(1)）
   - 函数调用开销（递归深度影响栈空间）

---

### **六、实战练习**
**问题**：分析以下代码的时间复杂度
```cpp
int func(int n) {
    int sum = 0;
    for (int i = 1; i <= n; i *= 2) {   // O(log n)
        for (int j = 0; j < i; j++) {   // O(i)
            sum++;
        }
    }
    return sum;
}
```

**解答**：
1. 外层循环：i取值1, 2, 4, ..., 2^k，共log₂n次
2. 内层循环：每次执行i次，总次数为1 + 2 + 4 + ... + 2^k = 2^(k+1) - 1 ≈ 2n
3. 总复杂度：O(n)

---

如果需要更深入的具体算法分析或复杂度优化建议，可以继续提问！